<html>

<head>
  <style>
    .board {
      display: grid;
      aspect-ratio: 1.5;
      width: 50%;
      grid-template-rows: repeat(20, 10%);
      grid-template-columns: repeat(10, 6.6%);
      /* The repeat() notation accepts 2 arguments: the first represents the number of times the defined tracks should repeat, and the second is the track definition. */
    }

    .cell {
      border: 1px solid black;
      border-top: 0;
      border-left: 0;
      box-sizing: border-box;
    }

    .cell.blue {
      background-color: blue;
    }

    .cell.green {
      background-color: limegreen;
    }

    .cell.red {
      background-color: red;
    }

    .cell.grey {
      background-color: grey;

      animation: bump 250ms ease-in-out;
    }

    .cell.yellow {
      background-color: gold;
    }

    .cell.purple {
      background-color: purple;
    }

    .cell.orange {
      background-color: orange;
    }

    @keyframes bump {
      0% {
        transform: translateY(5%);
      }

      100% {
        transform: translateY(0);
      }
    }


    /* 
    TODO: 
    
    - [x] can we give blocks that stop moving a "bump" animation? e.g. it moves past it's
          ending place ever so slightly, then rebounds back into place
    - [x] keep score
    - [ ] show upcoming piece
    - [x] make down arrow instantly drop piece, but allow for quick movement
          before the piece locks in place
    - [ ] remove Preact
    - [ ] Fix check to make sure pieces don't move off screen left/right when rotating
    */

  </style>
  <script type="module">
    import { h, Component, render } from 'https://unpkg.com/preact?module';
    import htm from 'https://unpkg.com/htm?module';

    // Initialize htm with Preact
    const html = htm.bind(h);

    class Game extends Component {

      constructor(props) {
        super(props);

        this.rowCount = 20;
        this.columnCount = 10;

        let cells = Array(this.rowCount * this.columnCount).fill(null);

        // create initial piece
        this.movingPiece = this.createPiece(cells);

        // set initial state
        this.state = { cells };

        this.score = 0;

        // bind global keyboard handlers
        window.addEventListener('keydown', this.onKeyDown.bind(this));
        window.addEventListener('keyup', this.onKeyUp.bind(this));

        // update loop
        this.interval = setInterval(this.update.bind(this), 100);
        this.previousTime = performance.now();
        this.updateSpeedInMs = 500;
      }

      ArrowLeft() {
        this.move(-1);
      }

      ArrowRight() {
        this.move(1);
      }

      ArrowUp() {
        this.rotate(1);
      }

      ArrowDown() {
        // Allow the game to update faster if the player holds the "down" key
        // TODO: extract this magic number
        this.updateSpeedInMs = 75;
      }

      onKeyDown(event) {
        // If the `Game` component has a defined method that
        // is equal to the name of the pressed key...
        if (typeof this[event.key] === 'function') {
          event.preventDefault();

          // fire that method
          this[event.key]();
        }
      }

      // The only purpose of this handler is to slow piece speed
      onKeyUp(event) {
        if (event.key === 'ArrowDown') {
          event.preventDefault()

          // TODO: extract this magic number
          this.updateSpeedInMs = 500;
        }
      }

      rotate(direction) {
        let cells = [...this.state.cells];  // shallow clone

        // store new positions of block
        const newPositions = this.calcRotate(direction);

        // TODO: extract this
        const calcRow = index => Math.floor(index / this.columnCount);

        // delete old positions
        this.movingPiece.indices.forEach(i => { cells[i] = null; });

        // check validity of new position
        for (let i = 0; i < 4; i += 1) {
          const currentPosition = this.movingPiece.indices[i];
          const newPosition = newPositions[i];

          // don't allow movement past the edge of the screen
          // e.g. if any of the new indices are in a different row
          // TODO: fix this for rotation
          // if (calcRow(currentPosition) !== calcRow(newPosition)) {
          //   console.log(`canceling rotation; trying to move off edge of screen`);
          //   return;
          // }

          // don't allow moving into any occupied spaces
          if (cells[newPosition] !== null) {
            console.log(`canceling rotation; trying to move in an occupied space`);
            return;
          }
        }

        // if we've made it here, it means the new move is valid

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = this.movingPiece.color; })

        // save references to the new indexes of the piece
        this.movingPiece.indices = newPositions;

        // update state
        this.setState({ cells });
      }

      calcRotate(direction) {

        // TODO: refactor this garbage
        this.movingPiece.rotation += 90 * direction;
        if (this.movingPiece.rotation === 360) {
          this.movingPiece.rotation = 0;
        }

        let centerIndex = this.movingPiece.indices[0];

        switch (this.movingPiece.type) {
          case 'T':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              //   *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + 1,
                centerIndex + this.columnCount
              ];
            } else if (this.movingPiece.rotation === 90) {
              //   *
              // *[*]
              //   *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex - this.columnCount,
                centerIndex + this.columnCount
              ];
            } else if (this.movingPiece.rotation === 180) {
              //   *
              // *[*]*
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + 1,
                centerIndex - this.columnCount
              ];
            } else if (this.movingPiece.rotation === 270) {
              //   *
              //  [*]*
              //   *
              return [
                centerIndex,
                centerIndex + 1,
                centerIndex - this.columnCount,
                centerIndex + this.columnCount
              ];
            }
            break;

          case 'O':
            // no-op
            return [
              centerIndex,
              centerIndex + 1,
              centerIndex + this.columnCount,
              centerIndex + this.columnCount + 1
            ];
            break;
          case 'S':
            // this condition matches 0 and 180
            if (this.movingPiece.rotation % 180 === 0) {
              //  [*]*
              // * *
              return [
                centerIndex,
                centerIndex + 1,
                centerIndex + this.columnCount,
                centerIndex + this.columnCount - 1
              ];
            } else {
              //  *
              // [*]*
              //   *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex + 1,
                centerIndex + this.columnCount + 1
              ];
            }
            break;
          case 'Z':
            // this condition matches 0 and 180
            if (this.movingPiece.rotation % 180 === 0) {
              // *[*]
              //   * *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + this.columnCount,
                centerIndex + this.columnCount + 1
              ];
            } else {
              //   *
              // *[*]
              // *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex - 1,
                centerIndex + this.columnCount - 1
              ];
            }
            break;
          case 'L':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              // *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + 1,
                centerIndex + this.columnCount - 1
              ];
            } else if (this.movingPiece.rotation === 90) {
              // *
              //[*]
              // * *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex + this.columnCount,
                centerIndex + this.columnCount + 1
              ];
            } else if (this.movingPiece.rotation === 180) {
              //     *
              // *[*]*
              return [
                centerIndex,
                centerIndex - this.columnCount + 1,
                centerIndex - 1,
                centerIndex + 1
              ];
            } else {
              // * *
              //  [*]
              //   *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex - this.columnCount - 1,
                centerIndex + this.columnCount
              ];
            }
            break;
          case 'J':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              //     *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + 1,
                centerIndex + this.columnCount + 1
              ];
            } else if (this.movingPiece.rotation === 90) {
              //   *
              //  [*]
              // * *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex + this.columnCount,
                centerIndex + this.columnCount - 1
              ];
            } else if (this.movingPiece.rotation === 180) {
              // *
              // *[*]*
              return [
                centerIndex,
                centerIndex - this.columnCount - 1,
                centerIndex - 1,
                centerIndex + 1
              ];
            } else {
              //  * *
              // [*]
              //  *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex - this.columnCount + 1,
                centerIndex + this.columnCount
              ];
            }
            break;
          case 'I':
            if (this.movingPiece.rotation % 180 === 0) {
              // *[*]* *
              return [
                centerIndex,
                centerIndex - 1,
                centerIndex + 1,
                centerIndex + 2
              ];
            } else {
              //  *
              // [*]
              //  *
              //  *
              return [
                centerIndex,
                centerIndex - this.columnCount,
                centerIndex + this.columnCount,
                centerIndex + this.columnCount * 2
              ];
            }
            break;
        }
      }

      // direction is +1 or -1
      move(direction) {
        let cells = [...this.state.cells];  // shallow clone

        // store new positions of block
        const newPositions = this.movingPiece.indices.map(i => i + direction);

        // TODO: extract this
        const calcRow = index => Math.floor(index / this.columnCount);

        // delete old positions
        this.movingPiece.indices.forEach(i => { cells[i] = null; })

        // check validity of new position
        for (let i = 0; i < 4; i += 1) {
          const currentPosition = this.movingPiece.indices[i];
          const newPosition = newPositions[i];

          // don't allow movement past the edge of the screen
          // e.g. if any of the new indices are in a different row
          if (calcRow(currentPosition) !== calcRow(newPosition)) {
            return;
          }

          // don't allow moving into any occupied spaces
          if (cells[newPosition] !== null) {
            return;
          }
        }

        // if we've made it here, it means the new move is valid

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = this.movingPiece.color; })

        // save references to the new indexes of the piece
        this.movingPiece.indices = newPositions;

        // update state
        this.setState({ cells });
      }

      ' '() {
        // console.log('lol space');

        // DEBUG
        this.dumpState()

        // TODO: rotate piece
        // how the heck to do this? similar to moving piece downwards,
        // calculate the new index positions, verify that they don't intersect
        // any stopped blocks, then delete the old and place the new

        // TODO: determine which cell to rotate the whole block around; how to store
        // that cell

        // can we do something like add the column value plus an offset?
        // e.g. if a cell is 1 above the pivot, it needs to move: + colCount + 1
        // if a cell is 1 to the right, it needs to move: + colCount - 1
        // if cell is below, it needs to move: - colCount - 1
        // if cell is left, it needs to move: - colCount + 1
        // in these cases, the +/- 1 is the distance from the pivot

        // OR store the type of block along with the index
        // functions to determine the new 
      }

      dumpState() {
        for (let row = 0; row < this.rowCount; row += 1) {
          console.log(this.state.cells.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }
      }

      // given a specific index to center the piece around,
      // populate `this.cells` with a tetrad, and return the
      // indices of the piece blocks
      createPiece(cells) {
        // Place the new piece at the top of the screen, in the middle of the grid
        const centerIndex = Math.floor(this.columnCount / 2);

        const shapes = ['O', 'S', 'Z', 'T', 'L', 'J', 'I'];

        let shapeType = shapes[Math.floor(Math.random() * shapes.length)]

        let color = Math.floor(Math.random() * 6) + 1;

        // TODO: `calcRotate` inspects state of the piece;
        // change to accept args instead
        this.movingPiece = {
          rotation: 270,
          indices: [centerIndex],
          type: shapeType
        };

        let shapeIndices = this.calcRotate(1);

        // `cantPlace` means that there's garbage where the piece should
        // spawn, and basically you lose the game
        let cantPlace = false;

        shapeIndices.forEach(i => {
          if (cells[i] !== null) {
            cantPlace = true;
          }

          cells[i] = color;
        });

        if (cantPlace) {
          return false;
        }

        return {
          indices: shapeIndices,
          type: shapeType,
          rotation: 0,
          color: color
        };
      }

      // remove any row that is full of stopped blocks
      // basically go through each row, and if every column cell is "filled"
      // then the `clear` var remains true, which then triggers the clear at
      // the end of the loop
      clearRows(cells) {
        // used for a scoring multiplier
        let clearedRowCount = 0;

        for (let row = 0; row < this.rowCount; row += 1) {
          let clear = true;

          for (let col = 0; col < this.columnCount; col += 1) {
            let index = row * this.columnCount + col;

            // if any cell in the row is empty, we can skip and move to the next
            if (cells[index] === null) {
              clear = false;
              break;
            }
          }

          if (clear === true) {
            clearedRowCount += 1;

            const rowStartIndex = row * this.columnCount;
            let emptyRow = cells.splice(rowStartIndex, this.columnCount);

            // push new blank cells on the top of the state array
            for (let col = 0; col < this.columnCount; col += 1) {
              cells.unshift(null);
            }
          }
        }

        switch (clearedRowCount) {
          case 1:
            this.score += 100;
            break;
          case 2:
            this.score += 300;
            break;
          case 3:
            this.score += 500;
            break;
          case 4:
            this.score += 800;
            break;
          default:
            // no points for u!
            break;
        }

        console.log(`Score: ${this.score}`);
      }

      update() {
        const now = performance.now();

        if (now - this.previousTime < this.updateSpeedInMs) {
          return;
        }

        this.previousTime = now;

        const cells = [...this.state.cells]; // shallow clone

        // store new positions of moving block
        const newPositions = this.movingPiece.indices.map(i => i + this.columnCount);

        // delete old positions
        this.movingPiece.indices.forEach(i => { cells[i] = null; })

        // check validity of all new positions
        for (let i = 0; i < 4; i += 1) {
          // if block would move off the bottom, or would move DOWN into a non-empty square...
          if (newPositions[i] > cells.length - 1 || cells[newPositions[i]] !== null) {
            // mark all pieces of the moving block as "stopped"
            this.movingPiece.indices.forEach(i => cells[i] = 0);

            // TODO: cells (passed by reference) is mutated
            this.clearRows(cells);

            // TODO: cells (passed by reference) is mutated
            this.movingPiece = this.createPiece(cells);

            // update state
            this.setState({ cells });

            // if piece can't be placed, game over!
            if (this.movingPiece === false) {
              this.gameOver();
            }

            return;
          }
        }

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = this.movingPiece.color; })

        // save references to the new indexes of the piece
        this.movingPiece.indices = newPositions;

        // update state
        this.setState({ cells });
      }

      gameOver() {
        clearInterval(this.interval);
        console.log('u lose!');
      }

      render() {
        return html`<div class="game">
              <${Board} cells=${this.state.cells} onClick=${this.onClick} />
          </div>`;
      }
    };

    const Board = props => {
      // TODO: move this to be accessible somewhere else?
      const colorMap = {
        0: 'grey',
        1: 'red',
        2: 'blue',
        3: 'yellow',
        4: 'green',
        5: 'purple',
        6: 'orange',
        null: ''
      };

      return html`<section class="board">
                    ${props.cells.map((value, index) => html`
                        <${Cell} color=${colorMap[value]}
                                 index=${index} />
                    `)}
                </section>`;
    };

    const Cell = props => {
      return html`<div class="cell ${props.color}"
                       data-index=${props.index} />`;
    };

    render(html`<${Game} />`, document.body);
  </script>
</head>

<body>

</body>

</html>
