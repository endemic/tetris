<html>

<head>
  <style>
    .board {
      display: grid;
      aspect-ratio: 1.5;
      width: 50%;
      grid-template-rows: repeat(20, 10%);
      grid-template-columns: repeat(10, 6.6%);
      /* The repeat() notation accepts 2 arguments: the first represents the number of times the defined tracks should repeat, and the second is the track definition. */
    }

    .cell {
      border: 1px solid black;
      border-top: 0;
      border-left: 0;
      box-sizing: border-box;
    }

    .cell.blue {
      background-color: blue;
    }

    .cell.green {
      background-color: limegreen;
    }

    .cell.red {
      background-color: red;
    }

    .cell.grey {
      background-color: grey;
    }

    .cell.yellow {
      background-color: yellow;
    }

    .cell.purple {
      background-color: purple;
    }

    .cell.orange {
      background-color: orange;
    }

    /* TODO: can we add css transitions that "slide" the background from top to bottom,
    to give the illusion of smooth animation?
    TODO: can we give blocks that stop moving a "bump" animation? e.g. it moves past it's
    ending place ever so slightly, then rebounds back into place;  */

  </style>
  <script type="module">
    import { h, Component, render } from 'https://unpkg.com/preact?module';
    import htm from 'https://unpkg.com/htm?module';

    // Initialize htm with Preact
    const html = htm.bind(h);

    class Game extends Component {

      constructor(props) {
        super(props);

        this.rowCount = 20;
        this.columnCount = 10;

        let cells = Array(this.rowCount * this.columnCount).fill(null);

        // create initial piece
        this.movingPiece = this.createPiece(cells);

        // set initial state
        this.state = { cells };

        // bind context variable to the current object
        this.update = this.update.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);

        // bind global keyboard handler
        window.addEventListener('keydown', this.onKeyDown);

        // update loop every second
        this.interval = setInterval(this.update, 100);
      }

      onClick(event) {
        return;

        let cells = [...this.state.cells];  // shallow clone
        let clickedIndex = parseInt(event.target.dataset['index'], 10);
        console.log(`clicked ${clickedIndex}`);

        if (cells[clickedIndex] !== null) {
          // don't do anything if the cell is filled
          return;
        }

        cells[clickedIndex] = {
          moving: true,
          color: 'red'
        }

        this.setState({ cells });
      }

      ArrowLeft() {
        this.move(-1);
      }

      ArrowRight() {
        this.move(1);
      }

      ArrowUp() {
        console.log('up arrow pressed; TODO something?');
      }

      ArrowDown() {
        console.log('down arrow pressed; TODO something?');
      }

      // direction is +1 or -1
      move(direction) {
        let cells = [...this.state.cells];  // shallow clone

        // store new positions of block
        const newPositions = this.movingPiece.map(i => i + direction);

        // TODO: extract this
        const calcRow = index => Math.floor(index / this.columnCount);

        // persist the color of the piece
        // TODO: rename `movingPiece` to `movingPieceIndexes` or similar
        const color = cells[this.movingPiece[0]];

        // delete old positions
        this.movingPiece.forEach(i => { cells[i] = null; })

        // check validity of new position
        for (let i = 0; i < 4; i += 1) {
          const currentPosition = this.movingPiece[i];
          const newPosition = newPositions[i];

          // don't allow movement past the edge of the screen
          // e.g. if any of the new indices are in a different row
          if (calcRow(currentPosition) !== calcRow(newPosition)) {
            return;
          }

          // don't allow moving into any occupied spaces
          if (cells[newPosition] !== null) {
            return;
          }
        }

        // if we've made it here, it means the new move is valid

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = color; })

        // save references to the new indexes of the piece
        this.movingPiece = newPositions;

        // update state
        this.setState({ cells });
      }

      ' '() {
        // console.log('lol space');

        // DEBUG
        this.dumpState()

        // TODO: rotate piece
        // how the heck to do this? similar to moving piece downwards,
        // calculate the new index positions, verify that they don't intersect
        // any stopped blocks, then delete the old and place the new

        // TODO: determine which cell to rotate the whole block around; how to store
        // that cell

        // can we do something like add the column value plus an offset?
        // e.g. if a cell is 1 above the pivot, it needs to move: + colCount + 1
        // if a cell is 1 to the right, it needs to move: + colCount - 1
        // if cell is below, it needs to move: - colCount - 1
        // if cell is left, it needs to move: - colCount + 1
        // in these cases, the +/- 1 is the distance from the pivot
      }

      dumpState() {
        for (let row = 0; row < this.rowCount; row += 1) {
          console.log(this.state.cells.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }
      }

      onKeyDown(event) {
        // If the `Game` component has a defined method that
        // is equal to the name of the pressed key...
        if (typeof this[event.key] === 'function') {
          // fire that method
          this[event.key]();
        }
      }

      // given a specific index to center the piece around,
      // populate `this.cells` with a tetrad, and return the
      // indices of the piece blocks
      createPiece(cells) {
        // TODO: should this be hard-coded?
        const centerIndex = 15;

        const shapes = {
          //  *
          // **
          //  *
          0: [
            centerIndex,
            centerIndex - 1,
            centerIndex - this.columnCount,
            centerIndex + this.columnCount
          ],

          // **
          // **
          1: [
            centerIndex,
            centerIndex + 1,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount + 1
          ],

          // **
          //  **
          2: [
            centerIndex,
            centerIndex - 1,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount + 1
          ],

          //  **
          // **
          3: [
            centerIndex,
            centerIndex + 1,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount - 1
          ],

          // *
          // *
          // **
          4: [
            centerIndex,
            centerIndex - this.columnCount,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount + 1
          ],

          //  *
          //  *
          // **
          5: [
            centerIndex,
            centerIndex - this.columnCount,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount - 1
          ],

          // *
          // *
          // *
          // *
          6: [
            centerIndex,
            centerIndex - this.columnCount,
            centerIndex + this.columnCount,
            centerIndex + this.columnCount * 2
          ]
        };

        let randomShape = shapes[Math.floor(Math.random() * 7)]
        let randomColor = Math.floor(Math.random() * 6) + 1;

        randomShape.forEach(i => {
          cells[i] = randomColor;
        });

        return randomShape;
      }

      clearRows(cells) {
        // remove any row that is full of stopped blocks
        // basically go through each row, and if every column cell is "filled"
        // then the `clear` var remains true, which then triggers the clear at
        // the end of the loop
        for (let row = 0; row < this.rowCount; row += 1) {
          let clear = true;

          for (let col = 0; col < this.columnCount; col += 1) {
            let index = row * this.columnCount + col;

            // if any cell in the row is empty, we can skip and move to the next
            if (cells[index] === null) {
              clear = false;
              break;
            }
          }

          if (clear === true) {
            console.log(`clearing row ${row}`);

            const rowStartIndex = row * this.columnCount;
            let emptyRow = cells.splice(rowStartIndex, this.columnCount);

            // push new blank cells on the top of the state array
            for (let col = 0; col < this.columnCount; col += 1) {
              cells.unshift(null);
            }

            // decrement the row counter, as we've mutated the array while looping over it
            // TODO: is this necessary?
            row -= 1;
          }
        }
      }

      update() {
        const cells = [...this.state.cells]; // shallow clone

        // store new positions of moving block
        const newPositions = this.movingPiece.map(i => i + this.columnCount);

        // TODO: check for lose condition; perhaps if piece is spawned on top of
        // an existing filled block

        // persist the color of the piece
        // TODO: rename `movingPiece` to `movingPieceIndexes` or similar
        const color = cells[this.movingPiece[0]];

        // delete old positions
        this.movingPiece.forEach(i => { cells[i] = null; })

        // check validity of all new positions
        for (let i = 0; i < 4; i += 1) {
          // if block would move off the bottom, or would move DOWN into a non-empty square...
          if (newPositions[i] > cells.length - 1 || cells[newPositions[i]] !== null) {
            // mark all pieces of the moving block as "stopped"
            this.movingPiece.forEach(i => cells[i] = 0);

            // TODO: cells (passed by reference) is mutated
            this.clearRows(cells);

            // TODO: cells (passed by reference) is mutated
            this.movingPiece = this.createPiece(cells);

            // update state
            this.setState({ cells });

            return;
          }
        }

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = color; })

        // save references to the new indexes of the piece
        this.movingPiece = newPositions;

        // update state
        this.setState({ cells });
      }

      render() {
        return html`<div class="game">
              <${Board} cells=${this.state.cells} onClick=${this.onClick} />
          </div>`;
      }
    };

    const Board = props => {
      // TODO: eventually remove the onClick handler, as this'll have keyboard
      // or touch-based controller

      // TODO: move this to be accessible somewhere else?
      const colorMap = {
        0: 'grey',
        1: 'red',
        2: 'blue',
        3: 'yellow',
        4: 'green',
        5: 'purple',
        6: 'orange',
        null: ''
      };

      return html`<section class="board">
                    ${props.cells.map((value, index) => html`
                        <${Cell} color=${colorMap[value]}
                                 index=${index}
                                 onClick=${props.onClick} />
                    `)}
                </section>`;
    };

    const Cell = props => {
      return html`<div class="cell ${props.color}"
                       data-index=${props.index}
                       onClick=${props.onClick} />`;
    };

    render(html`<${Game} />`, document.body);
  </script>
</head>

<body>

</body>

</html>
