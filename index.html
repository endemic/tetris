<html>

<head>
  <link rel="stylesheet" href="stylesheets/main.css">
  <script src="grid.js"></script>
  <script type="module">
    /* 
    TODO: 
    
    - [x] can we give blocks that stop moving a "bump" animation? e.g. it moves past it's
          ending place ever so slightly, then rebounds back into place
    - [x] keep score
    - [ ] show upcoming piece
    - [x] make down arrow instantly drop piece, but allow for quick movement
          before the piece locks in place
    - [ ] remove Preact
    - [ ] Fix check to make sure pieces don't move off screen left/right when rotating
    */

    const EMPTY = null;

    class Game extends Grid {
      cssClassMap = {
        0: 'grey',
        1: 'red',
        2: 'blue',
        3: 'yellow',
        4: 'green',
        5: 'purple',
        6: 'orange',
        null: ''
      }

      constructor() {
        let rows = 20;
        let columns = 10;

        super(rows, columns);

        let nextDisplayState = this.displayStateCopy();
        this.fill(nextDisplayState, EMPTY);

        // create initial piece
        this.movingPiece = this.createPiece(nextDisplayState);

        this.render(nextDisplayState);

        this.score = 0;

        // bind global keyboard handlers
        window.addEventListener('keydown', this.onKeyDown.bind(this));
        window.addEventListener('keyup', this.onKeyUp.bind(this));

        // update loop
        this.interval = setInterval(this.update.bind(this), 100);
        this.previousTime = performance.now();
        this.updateSpeedInMs = 500;
      }

      ArrowLeft() {
        this.move(-1);
      }

      ArrowRight() {
        this.move(1);
      }

      ArrowUp() {
        this.rotate(1);
      }

      ArrowDown() {
        // Allow the game to update faster if the player holds the "down" key
        // TODO: extract this magic number
        this.updateSpeedInMs = 75;
      }

      onKeyDown(event) {
        // If the `Game` component has a defined method that
        // is equal to the name of the pressed key...
        if (typeof this[event.key] === 'function') {
          event.preventDefault();

          // fire that method
          this[event.key]();
        }
      }

      // The only purpose of this handler is to slow piece speed
      onKeyUp(event) {
        if (event.key === 'ArrowDown') {
          event.preventDefault()

          // TODO: extract this magic number
          this.updateSpeedInMs = 500;
        }
      }

      rotate(direction) {
        let newDisplayState = this.displayStateCopy();

        // store new positions of block
        const newPositions = this.calcRotate(direction);

        // delete old positions
        this.movingPiece.position.forEach(({ x: x, y: y }) => { newDisplayState[x][y] = EMPTY; });

        // check validity of new position
        for (let i = 0; i < 4; i += 1) {
          const currentPoint = this.movingPiece.position[i];
          const newPosition = newPositions[i];

          // don't allow any blocks to move past the edge of the grid
          // TODO: allow blocks to "push" themselves away from edges when rotating
          if (newPosition.x < 0 || newPosition.x >= this.columns) {
            return;
          }

          // don't allow moving into any occupied spaces
          if (newDisplayState[newPosition.x][newPosition.y] !== EMPTY) {
            console.log(`canceling rotation; trying to move in an occupied space`);
            return;
          }
        }

        // if we've made it here, it means the new move is valid

        // put new blocks in place
        newPositions.forEach(({ x: x, y: y }) => { newDisplayState[x][y] = this.movingPiece.color; })

        // save references to the new indexes of the piece
        this.movingPiece.position = newPositions;

        this.render(newDisplayState)
      }

      // @return Array of points representing the position of a tetrad
      calcRotate(direction) {

        // TODO: refactor this garbage
        this.movingPiece.rotation += 90 * direction;
        if (this.movingPiece.rotation === 360) {
          this.movingPiece.rotation = 0;
        }

        let center = this.movingPiece.position[0];

        switch (this.movingPiece.type) {
          case 'T':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              //   *
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x + 1, y: center.y },
                { x: center.x, y: center.y + 1 },
              ];
            } else if (this.movingPiece.rotation === 90) {
              //   *
              // *[*]
              //   *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x - 1, y: center.y },
                { x: center.x, y: center.y + 1 },
              ];
            } else if (this.movingPiece.rotation === 180) {
              //   *
              // *[*]*
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x, y: center.y - 1 },
                { x: center.x + 1, y: center.y },
              ];
            } else if (this.movingPiece.rotation === 270) {
              //   *
              //  [*]*
              //   *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x + 1, y: center.y },
                { x: center.x, y: center.y + 1 },
              ];
            }
            break;

          case 'O':
            // no-op
            return [
              center,
              { x: center.x, y: center.y + 1 },
              { x: center.x + 1, y: center.y },
              { x: center.x + 1, y: center.y + 1 },
            ];
            break;
          case 'S':
            // this condition matches 0 and 180
            if (this.movingPiece.rotation % 180 === 0) {
              //  [*]*
              // * *
              return [
                center,
                { x: center.x + 1, y: center.y },
                { x: center.x, y: center.y + 1 },
                { x: center.x - 1, y: center.y + 1 },
              ];
            } else {
              //  *
              // [*]*
              //   *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x + 1, y: center.y },
                { x: center.x + 1, y: center.y + 1 },
              ];
            }
            break;
          case 'Z':
            // this condition matches 0 and 180
            if (this.movingPiece.rotation % 180 === 0) {
              // *[*]
              //   * *
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x, y: center.y + 1 },
                { x: center.x + 1, y: center.y + 1 },
              ];
            } else {
              //   *
              // *[*]
              // *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x - 1, y: center.y },
                { x: center.x - 1, y: center.y + 1 },
              ];
            }
            break;
          case 'L':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              // *
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x - 1, y: center.y + 1 },
                { x: center.x + 1, y: center.y },
              ];
            } else if (this.movingPiece.rotation === 90) {
              // * *
              //  [*]
              //   *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x - 1, y: center.y - 1 },
                { x: center.x, y: center.y + 1 },
              ];
            } else if (this.movingPiece.rotation === 180) {
              //     *
              // *[*]*
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x + 1, y: center.y },
                { x: center.x + 1, y: center.y + 1 },
              ];
            } else {
              // *
              //[*]
              // * *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x, y: center.y + 1 },
                { x: center.x + 1, y: center.y + 1 },
              ];
            }
            break;
          case 'J':
            if (this.movingPiece.rotation === 0) {
              // *[*]*
              //     *
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x + 1, y: center.y },
                { x: center.x + 1, y: center.y + 1 },
              ];
            } else if (this.movingPiece.rotation === 90) {
              //   *
              //  [*]
              // * *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x, y: center.y + 1 },
                { x: center.x - 1, y: center.y + 1 },
              ];
            } else if (this.movingPiece.rotation === 180) {
              // *
              // *[*]*
              return [
                center,
                { x: center.x - 1, y: center.y - 1 },
                { x: center.x - 1, y: center.y },
                { x: center.x + 1, y: center.y },
              ];
            } else {
              //  * *
              // [*]
              //  *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x + 1, y: center.y - 1 },
                { x: center.x, y: center.y + 1 },
              ];
            }
            break;
          case 'I':
            if (this.movingPiece.rotation % 180 === 0) {
              // *[*]* *
              return [
                center,
                { x: center.x - 1, y: center.y },
                { x: center.x + 1, y: center.y },
                { x: center.x + 2, y: center.y },
              ];
            } else {
              //  *
              // [*]
              //  *
              //  *
              return [
                center,
                { x: center.x, y: center.y - 1 },
                { x: center.x, y: center.y + 1 },
                { x: center.x, y: center.y + 2 },
              ];
            }
            break;
        }
      }

      // direction is 1 or -1
      move(direction) {
        let newDisplayState = this.displayStateCopy();

        // store new positions of block
        const newPositions = this.movingPiece.position.map(({ x, y }) => {
          return { x: x + direction, y: y };
        });

        // delete old positions
        this.movingPiece.position.forEach(({ x, y }) => newDisplayState[x][y] = EMPTY)

        // check validity of new position
        for (let i = 0; i < 4; i += 1) {
          const currentPoint = this.movingPiece.position[i];
          const newPosition = newPositions[i];

          // don't allow movement past the edge of the screen
          if (newPosition.x < 0 || newPosition.x >= this.columns) {
            return;
          }

          // don't allow moving into any occupied spaces
          if (newDisplayState[newPosition.x][newPosition.y] !== EMPTY) {
            return;
          }
        }

        // if we've made it here, it means the new move is valid

        // put new blocks in place
        newPositions.forEach(({ x, y }) => newDisplayState[x][y] = this.movingPiece.color);

        // save references to the new indexes of the piece
        this.movingPiece.position = newPositions;

        // update state
        this.render(newDisplayState);
      }

      ' '() {
        // console.log('lol space');

        // DEBUG
        this.dumpState()

        // TODO: rotate piece
        // how the heck to do this? similar to moving piece downwards,
        // calculate the new index positions, verify that they don't intersect
        // any stopped blocks, then delete the old and place the new

        // TODO: determine which cell to rotate the whole block around; how to store
        // that cell

        // can we do something like add the column value plus an offset?
        // e.g. if a cell is 1 above the pivot, it needs to move: + colCount + 1
        // if a cell is 1 to the right, it needs to move: + colCount - 1
        // if cell is below, it needs to move: - colCount - 1
        // if cell is left, it needs to move: - colCount + 1
        // in these cases, the +/- 1 is the distance from the pivot

        // OR store the type of block along with the index
        // functions to determine the new 
      }

      dumpState() {
        for (let row = 0; row < this.rowCount; row += 1) {
          console.log(this.state.cells.slice(row * this.columnCount, row * this.columnCount + this.columnCount))
        }
      }

      // given a specific index to center the piece around,
      // populate `this.cells` with a tetrad, and return the
      // indices of the piece blocks
      createPiece(cells) {
        // Place the new piece at the top of the screen, in the middle of the grid
        const centerPoint = {
          x: Math.floor(this.columns / 2),
          y: 0
        };

        const shapes = ['O', 'S', 'Z', 'T', 'L', 'J', 'I'];

        let shapeType = shapes[Math.floor(Math.random() * shapes.length)]

        let color = Math.floor(Math.random() * 6) + 1;

        // TODO: `calcRotate` inspects state of the piece;
        // change to accept args instead
        this.movingPiece = {
          rotation: 270,
          position: [centerPoint],
          type: shapeType
        };

        let shapePoints = this.calcRotate(1);

        // `cantPlace` means that there's garbage where the piece should
        // spawn, and basically you lose the game
        let cantPlace = false;

        shapePoints.forEach(({ x: x, y: y }) => {
          if (cells[x][y] !== EMPTY) {
            cantPlace = true;
          }

          cells[x][y] = color;
        });

        if (cantPlace) {
          return false;
        }

        return {
          position: shapePoints,
          type: shapeType,
          rotation: 0,
          color: color
        };
      }

      // remove any row that is full of stopped blocks
      // basically go through each row, and if every column cell is "filled"
      // then the `clear` var remains true, which then triggers the clear at
      // the end of the loop
      clearRows(cells) {
        // used for a scoring multiplier
        let clearedRowCount = 0;

        for (let row = 0; row < this.rowCount; row += 1) {
          let clear = true;

          for (let col = 0; col < this.columnCount; col += 1) {
            let index = row * this.columnCount + col;

            // if any cell in the row is empty, we can skip and move to the next
            if (cells[index] === null) {
              clear = false;
              break;
            }
          }

          if (clear === true) {
            clearedRowCount += 1;

            const rowStartIndex = row * this.columnCount;
            let emptyRow = cells.splice(rowStartIndex, this.columnCount);

            // push new blank cells on the top of the state array
            for (let col = 0; col < this.columnCount; col += 1) {
              cells.unshift(null);
            }
          }
        }

        switch (clearedRowCount) {
          case 1:
            this.score += 100;
            break;
          case 2:
            this.score += 300;
            break;
          case 3:
            this.score += 500;
            break;
          case 4:
            this.score += 800;
            break;
          default:
            // no points for u!
            break;
        }

        console.log(`Score: ${this.score}`);
      }

      update() {
        const now = performance.now();

        if (now - this.previousTime < this.updateSpeedInMs) {
          return;
        }

        this.previousTime = now;

        const nextDisplayState = this.displayStateCopy();

        // store new positions of moving block
        const newPositions = this.movingPiece.position.map(point => {
          return { x: point.x, y: point.y + 1 }
        });

        // delete old positions
        this.movingPiece.position.forEach(({ x: x, y: y }) => nextDisplayState[x][y] = null)

        // check validity of all new positions
        for (let i = 0; i < 4; i += 1) {
          let point = newPositions[i];
          // if block would move off the bottom, or would move DOWN into a non-empty square...
          if (point.y >= this.rows || nextDisplayState[point.x][point.y] !== null) {
            // mark all pieces of the moving block as "stopped"
            this.movingPiece.position.forEach(({ x: x, y: y }) => nextDisplayState[x][y] = 0);

            // TODO: cells (passed by reference) is mutated
            this.clearRows(nextDisplayState);

            // TODO: cells (passed by reference) is mutated
            this.movingPiece = this.createPiece(nextDisplayState);

            this.render(nextDisplayState);

            // if piece can't be placed, game over!
            if (this.movingPiece === false) {
              this.gameOver();
            }

            return;
          }
        }

        // put blocks in place in new position
        newPositions.forEach(({ x: x, y: y }) => { nextDisplayState[x][y] = this.movingPiece.color; })

        // save references to the new position of the piece
        this.movingPiece.position = newPositions;

        // update state
        this.render(nextDisplayState)
      }

      gameOver() {
        clearInterval(this.interval);
        console.log('u lose!');
      }
    };

    new Game();
  </script>
</head>

<body>
  <section id="grid"></section>
</body>

</html>
