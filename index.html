<html>

<head>
  <style>
    .board {
      display: grid;
      aspect-ratio: 1.5;
      width: 50%;
      grid-template-rows: repeat(20, 10%);
      grid-template-columns: repeat(10, 6.6%);
      /* The repeat() notation accepts 2 arguments: the first represents the number of times the defined tracks should repeat, and the second is the track definition. */
    }

    .cell {
      border: 1px solid black;
      border-top: 0;
      border-left: 0;
      box-sizing: border-box;
    }

    .cell.blue {
      background-color: blue;
    }

    .cell.green {
      background-color: limegreen;
    }

    .cell.red {
      background-color: red;
    }

    .cell.grey {
      background-color: grey;
    }

    /* TODO: can we add css transitions that "slide" the background from top to bottom,
    to give the illusion of smooth animation?
    TODO: can we give blocks that stop moving a "bump" animation? e.g. it moves past it's
    ending place ever so slightly, then rebounds back into place;  */

  </style>
  <script type="module">
    import { h, Component, render } from 'https://unpkg.com/preact?module';
    import htm from 'https://unpkg.com/htm?module';

    // Initialize htm with Preact
    const html = htm.bind(h);

    class Game extends Component {

      constructor(props) {
        super(props);

        this.rowCount = 20;
        this.columnCount = 10;

        let cells = Array(this.rowCount * this.columnCount).fill(null);

        this.state = { cells };

        // console.log(this.state.cells);

        this.blockProto = { moving: true, color: 'green' };

        // initialize first block
        // cells[3] = structuredClone(this.blockProto);
        // cells[12] = { moving: true, color: 'green' };
        // cells[13] = { moving: true, color: 'green' };
        // cells[23] = { moving: true, color: 'green' };

        // 
        this.movingPiece = this.createPiece(15);

        // TODO: holds references to the cells that represent the currently moving piece
        // this.movingPiece = [3, 12, 13, 23];
        // this.movingPiece = [3];

        // this.setState({ cells });

        // bind context variable to the current object
        this.update = this.update.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);

        // bind global keyboard handler
        window.addEventListener('keydown', this.onKeyDown);

        // update loop every second
        this.interval = setInterval(this.update, 500);
      }

      onClick(event) {
        return;

        let cells = [...this.state.cells];  // shallow clone
        let clickedIndex = parseInt(event.target.dataset['index'], 10);
        console.log(`clicked ${clickedIndex}`);

        if (cells[clickedIndex] !== null) {
          // don't do anything if the cell is filled
          return;
        }

        cells[clickedIndex] = {
          moving: true,
          color: 'red'
        }

        this.setState({ cells });
      }

      ArrowLeft() {
        let cells = [...this.state.cells];  // shallow clone

        // store new positions of block
        const newPositions = this.movingPiece.map(i => i - 1);
        console.log(newPositions)

        // persist the color of the piece
        // TODO: rename `movingPiece` to `movingPieceIndexes` or similar
        const color = cells[this.movingPiece[0]];
        console.log(`saved color: ${color}`);

        // delete old positions
        this.movingPiece.forEach(i => { cells[i] = null; })

        // put new blocks in place
        newPositions.forEach(i => { cells[i] = color; })

        // save references to the new indexes of the piece
        this.movingPiece = newPositions;

        // TODO: need to copy all cells to the new positions, then remove the old positions
        // problem: if the old position is still filled, this process would delete it
        // do we have to represent blocks as objects? could use 0-9, 0 being stopped blocks
        // and 1-9 being different colors
        // for (let i = 0; i < this.movingPiece.length; i += 1) {
        //   let index = this.movingPiece[i];
        //   let val = cells[index];
        //   console.log(`cell index to move: ${index}`);

        //   // move the cell state one to the left
        //   cells[index - 1] = val;
        //   cells[index] = null;

        //   // make the piece index reference reflect the new cell state
        //   this.movingPiece[i] = index - 1;
        //   console.log(`movingPiece[${i}]: ${this.movingPiece[i]}`);
        // }

        this.setState({ cells });
      }

      ArrowRight() {
        let cells = [...this.state.cells];  // shallow clone

        // increment each index by one
        for (let i = 0; i < this.movingPiece.length; i += 1) {
          let index = this.movingPiece[i];
          let val = cells[index];
          console.log(`cell index to move: ${index}`);

          // move the cell state one to the left
          cells[index + 1] = val;
          cells[index] = null;

          // make the piece index reference reflect the new cell state
          this.movingPiece[i] = index + 1;
          console.log(`movingPiece[${i}]: ${this.movingPiece[i]}`);
        }

        this.setState({ cells });
      }

      ArrowUp() {
        console.log('up arrow pressed; TODO something?');
      }

      ArrowDown() {
        console.log('down arrow pressed; TODO something?');
      }

      onKeyDown(event) {
        // If the `Game` component has a defined method that
        // is equal to the name of the pressed key...
        if (typeof this[event.key] === 'function') {
          // fire that method
          this[event.key]();
        }
      }

      // given a specific index to center the piece around,
      // populate `this.cells` with a tetrad, and return the
      // indices of the piece blocks
      createPiece(centerIndex) {
        let cells = [...this.state.cells];  // shallow clone

        // TODO: dynamically populate this list based on the type of tetrad we want

        //  *
        // **
        //  *
        const indices = [
          centerIndex,
          centerIndex - 1,
          centerIndex - this.columnCount,
          centerIndex + this.columnCount
        ];

        console.log(indices)

        indices.forEach(i => {
          cells[i] = 1; // red
        });

        this.setState({ cells });

        return indices;
      }

      update() {
        return;
        // move each dot downwards
        const cells = this.state.cells;

        for (let index = cells.length - 1; index >= 0; index -= 1) {
          if (cells[index] === null) {
            // skip the update if the current cell is empty
            continue;
          }

          let newIndex = index + this.columnCount;

          // 600 total cells
          if (newIndex > cells.length - 1 || cells[newIndex] !== null) {
            // stop moving if next is already filled
            // or if it would move off the bottom of the grid
            cells[index].moving = false;
            cells[index].color = 'grey';
            continue;
          }

          // console.log(`moving ${index} to ${newIndex}`);
          cells[newIndex] = cells[index];
          cells[index] = null;

          // move references to moving squares
          // TODO: this is super jank
          // is there a better way to reference a moving piece?

          // TODO: the above code iterates through every single cell
          // in a real Tetris game, you only control a single piece, and
          // know the position of it, so you only have to update a max of 4
          // cells per cycle

          const idx = this.movingPiece.indexOf(index);
          if (idx !== -1) {
            this.movingPiece[idx] = newIndex;
          }
        }

        // remove any row that has all stopped blocks
        // could optimize by doing this in the overall movement loop
        for (let row = 0; row < this.rowCount; row += 1) {
          let clear = true;

          for (let col = 0; col < this.columnCount; col += 1) {
            let index = row * this.columnCount + col;

            if (cells[index] === null || cells[index].moving === true) {
              // one of the spots in a row is unfilled or still moving;
              // so don't need to check the rest of the row
              clear = false;
              break;
            }
          }

          if (clear === true) {
            // blank out all the cells in the row
            for (let col = 0; col < this.columnCount; col += 1) {
              let index = row * this.columnCount + col;

              cells[index] = null;
            }
          }

          // update state
          this.setState({ cells });
        }
      }

      render() {
        return html`<div class="game">
              <${Board} cells=${this.state.cells} onClick=${this.onClick} />
          </div>`;
      }
    };

    const Board = props => {
      // TODO: eventually remove the onClick handler, as this'll have keyboard
      // or touch-based controller

      // TODO: move this to be accessible somewhere else?
      const colorMap = {
        0: 'grey',
        1: 'red',
        2: 'blue',
        3: 'yellow',
        4: 'green',
        5: 'purple',
        6: 'orange'
      };

      return html`<section class="board">
                    ${props.cells.map((value, index) => html`
                        <${Cell} color=${colorMap[value]}
                                 index=${index}
                                 onClick=${props.onClick} />
                    `)}
                </section>`;
    };

    const Cell = props => {
      return html`<div class="cell ${props.color}"
                       data-index=${props.index}
                       onClick=${props.onClick} />`;
    };

    render(html`<${Game} />`, document.body);
  </script>
</head>

<body>

</body>

</html>
